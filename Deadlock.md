# report 
### student number：14353223
### name: 罗海福
*	**Deadlock**
	*	死锁：死锁就是两个或多个进程，互相请求对方占有的资源。
	*	死锁产生的四个必要条件
		1.	互斥条件：一个资源每次只能被一个进程使用
		2.	请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
		3.	不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
		4.	循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系
*	**实验结果截图及解释**
	*	实验结果截图
	![](http://i1.piimg.com/567571/919123f2897dc69e.png)
	*	如图所示我们设置count等于20000；然后按照TA给的代码跑`bash bat`让Deadlock这个程序跑100遍，100次中总会有几次出现死锁。
	![](http://i1.piimg.com/567571/4508fab03e1b6b7b.png)
	*	按照TA的PPT来解释，我们Deadlock中一共有两个线程，主线程main和线程t，如图是主函数的时间轴，当t.start()之后，线程t就会跑到调度队列当中，当调度到他的时候就跑run()里面的代码，当线程t开始时，我们总会数两万个数再跑主线程，这个代码跑100次当中，总会有几次随机的出现main线程和主线程在同一时刻访问object的一个synchronized同步代码块。但是，当一个线程正在访问时，其他线程对其的访问将会被阻塞，直到他释放资源，这样就出现了死锁，即一个线程需要这个资源，而另一个线程不释放这个资源，因为他没有执行完，所以就随机停在某一次了。
*	**实验感想和体会**
	*	一开始始终不出现死锁，有可能是count的值太小了。本次实验我们更好清楚的理解到死锁的概念，以及死锁产生的四个条件，之所以用synchronized关键字，是因为它修饰一个方法或者一个代码块的时候，能够保证同一时刻最多有一个线程执行该段代码。这满足了死锁的互斥条件，当一个进程因为请求资源被阻塞时，对已获得的资源保持不放，并且在未使用完之前不能强行剥夺，另一个进程形成头尾相接的循环等待关系。更加清楚深刻的理解到死锁的四个条件，以及为什么会产生死锁，通过这四个条件可以进行死锁的预防。
	